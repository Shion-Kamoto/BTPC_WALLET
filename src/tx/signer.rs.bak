use anyhow::Result;
use base64::{engine::general_purpose, Engine as _};
use secrecy::ExposeSecret;

use pqcrypto_dilithium::dilithium5::{detached_sign, SecretKey};
use pqcrypto_traits::sign::{SecretKey as _, DetachedSignature as _};

/// Sign raw transaction bytes with Dilithium5 and return base64 signature.
/// Accepts secret key as SecretVec<u8> to avoid raw copies in call sites.
pub fn sign_tx(sk_secret: &secrecy::SecretVec<u8>, tx_bytes: &[u8]) -> Result<String> {
    let sk_bytes = sk_secret.expose_secret();
    let sk = SecretKey::from_bytes(sk_bytes).map_err(|_| anyhow::anyhow!("invalid secret key"))?;
    let sig = detached_sign(tx_bytes, &sk);
    Ok(general_purpose::STANDARD.encode(sig.as_bytes()))
}
